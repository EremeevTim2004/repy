Для простоты опишем рекурсивный алгоритм удаления.
Если вершина "--- лист, то удалим её и вызовем балансировку всех её предков в порядке от родителя к корню.
Иначе найдём самую близкую по значению вершину в поддереве наибольшей высоты (правом или левом) и переместим её на место удаляемой вершины,
при этом вызвав процедуру её удаления.

Докажем, что данный алгоритм сохраняет балансировку.
Для этого докажем по индукции по высоте дерева,
что после удаления некоторой вершины из дерева и
последующей балансировки высота дерева уменьшается не более, чем на 1.
База индукции: Для листа очевидно верно.
Шаг индукции: Либо условие балансированности в корне (после удаления корень может изменится) не нарушилось,
тогда высота данного дерева не изменилась,
либо уменьшилось строго меньшее из поддеревьев $ $
высота до балансировки не изменилась $ $
после уменьшится не более чем на 1.

Очевидно, в результате указанных действий процедура удаления вызывается не более 3 раз,
так как у вершины, удаляемой по 2-му вызову, нет одного из поддеревьев.
Но поиск ближайшего каждый раз требует $O(N)$ операций,
отсюда видна очевидная оптимизация:
поиск ближайшей вершины производится по краю поддерева.
Отсюда количество действий $O(\lg(N))$.